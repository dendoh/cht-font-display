#include <Wire.h>
#include "FS.h"
#include <ESP8266WiFi.h>
#include <Esp.h>


#define PIN_SCE   12
#define PIN_RESET 2
#define PIN_DC    5
#define PIN_SDIN  13
#define PIN_SCLK  14

#define LCD_C     LOW
#define LCD_D     HIGH

#define LCD_X     84
#define LCD_Y     48

const unsigned char asciibmp[]  = {
  0x08,0x10,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // columns, rows, nbytes
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // space 0x20
  0x00,0x00,0x18,0x3C,0x3C,0x3C,0x18,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00, // !
  0x00,0x63,0x63,0x63,0x22,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // "
  0x00,0x00,0x00,0x36,0x36,0x7F,0x36,0x36,0x36,0x7F,0x36,0x36,0x00,0x00,0x00,0x00, // #
  0x0C,0x0C,0x3E,0x63,0x61,0x60,0x3E,0x03,0x03,0x43,0x63,0x3E,0x0C,0x0C,0x00,0x00, // $
  0x00,0x00,0x00,0x00,0x00,0x61,0x63,0x06,0x0C,0x18,0x33,0x63,0x00,0x00,0x00,0x00, // %
  0x00,0x00,0x00,0x1C,0x36,0x36,0x1C,0x3B,0x6E,0x66,0x66,0x3B,0x00,0x00,0x00,0x00, // &
  0x00,0x30,0x30,0x30,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // '
  0x00,0x00,0x0C,0x18,0x18,0x30,0x30,0x30,0x30,0x18,0x18,0x0C,0x00,0x00,0x00,0x00, // (
  0x00,0x00,0x18,0x0C,0x0C,0x06,0x06,0x06,0x06,0x0C,0x0C,0x18,0x00,0x00,0x00,0x00, // )
  0x00,0x00,0x00,0x00,0x42,0x66,0x3C,0xFF,0x3C,0x66,0x42,0x00,0x00,0x00,0x00,0x00, // *
  0x00,0x00,0x00,0x00,0x18,0x18,0x18,0xFF,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0x00, // +
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x18,0x30,0x00,0x00, // ,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // -
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00, // .
  0x00,0x00,0x01,0x03,0x07,0x0E,0x1C,0x38,0x70,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00, // / (forward slash)
  0x00,0x00,0x3E,0x63,0x63,0x63,0x6B,0x6B,0x63,0x63,0x63,0x3E,0x00,0x00,0x00,0x00, // 0 0x30
  0x00,0x00,0x0C,0x1C,0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3F,0x00,0x00,0x00,0x00, // 1
  0x00,0x00,0x3E,0x63,0x03,0x06,0x0C,0x18,0x30,0x61,0x63,0x7F,0x00,0x00,0x00,0x00, // 2
  0x00,0x00,0x3E,0x63,0x03,0x03,0x1E,0x03,0x03,0x03,0x63,0x3E,0x00,0x00,0x00,0x00, // 3
  0x00,0x00,0x06,0x0E,0x1E,0x36,0x66,0x66,0x7F,0x06,0x06,0x0F,0x00,0x00,0x00,0x00, // 4
  0x00,0x00,0x7F,0x60,0x60,0x60,0x7E,0x03,0x03,0x63,0x73,0x3E,0x00,0x00,0x00,0x00, // 5
  0x00,0x00,0x1C,0x30,0x60,0x60,0x7E,0x63,0x63,0x63,0x63,0x3E,0x00,0x00,0x00,0x00, // 6
  0x00,0x00,0x7F,0x63,0x03,0x06,0x06,0x0C,0x0C,0x18,0x18,0x18,0x00,0x00,0x00,0x00, // 7
  0x00,0x00,0x3E,0x63,0x63,0x63,0x3E,0x63,0x63,0x63,0x63,0x3E,0x00,0x00,0x00,0x00, // 8
  0x00,0x00,0x3E,0x63,0x63,0x63,0x63,0x3F,0x03,0x03,0x06,0x3C,0x00,0x00,0x00,0x00, // 9
  0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00, // :
  0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x18,0x30,0x00,0x00, // ;
  0x00,0x00,0x00,0x06,0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x06,0x00,0x00,0x00,0x00, // <
  0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00, // =
  0x00,0x00,0x00,0x60,0x30,0x18,0x0C,0x06,0x0C,0x18,0x30,0x60,0x00,0x00,0x00,0x00, // >
  0x00,0x00,0x3E,0x63,0x63,0x06,0x0C,0x0C,0x0C,0x00,0x0C,0x0C,0x00,0x00,0x00,0x00, // ?
  0x00,0x00,0x3E,0x63,0x63,0x6F,0x6B,0x6B,0x6E,0x60,0x60,0x3E,0x00,0x00,0x00,0x00, // @ 0x40
  0x00,0x00,0x08,0x1C,0x36,0x63,0x63,0x63,0x7F,0x63,0x63,0x63,0x00,0x00,0x00,0x00, // A
  0x00,0x00,0x7E,0x33,0x33,0x33,0x3E,0x33,0x33,0x33,0x33,0x7E,0x00,0x00,0x00,0x00, // B
  0x00,0x00,0x1E,0x33,0x61,0x60,0x60,0x60,0x60,0x61,0x33,0x1E,0x00,0x00,0x00,0x00, // C
  0x00,0x00,0x7C,0x36,0x33,0x33,0x33,0x33,0x33,0x33,0x36,0x7C,0x00,0x00,0x00,0x00, // D
  0x00,0x00,0x7F,0x33,0x31,0x34,0x3C,0x34,0x30,0x31,0x33,0x7F,0x00,0x00,0x00,0x00, // E
  0x00,0x00,0x7F,0x33,0x31,0x34,0x3C,0x34,0x30,0x30,0x30,0x78,0x00,0x00,0x00,0x00, // F
  0x00,0x00,0x1E,0x33,0x61,0x60,0x60,0x6F,0x63,0x63,0x37,0x1D,0x00,0x00,0x00,0x00, // G
  0x00,0x00,0x63,0x63,0x63,0x63,0x7F,0x63,0x63,0x63,0x63,0x63,0x00,0x00,0x00,0x00, // H
  0x00,0x00,0x3C,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00, // I
  0x00,0x00,0x0F,0x06,0x06,0x06,0x06,0x06,0x06,0x66,0x66,0x3C,0x00,0x00,0x00,0x00, // J
  0x00,0x00,0x73,0x33,0x36,0x36,0x3C,0x36,0x36,0x33,0x33,0x73,0x00,0x00,0x00,0x00, // K
  0x00,0x00,0x78,0x30,0x30,0x30,0x30,0x30,0x30,0x31,0x33,0x7F,0x00,0x00,0x00,0x00, // L
  0x00,0x00,0x63,0x77,0x7F,0x6B,0x63,0x63,0x63,0x63,0x63,0x63,0x00,0x00,0x00,0x00, // M
  0x00,0x00,0x63,0x63,0x73,0x7B,0x7F,0x6F,0x67,0x63,0x63,0x63,0x00,0x00,0x00,0x00, // N
  0x00,0x00,0x1C,0x36,0x63,0x63,0x63,0x63,0x63,0x63,0x36,0x1C,0x00,0x00,0x00,0x00, // O
  0x00,0x00,0x7E,0x33,0x33,0x33,0x3E,0x30,0x30,0x30,0x30,0x78,0x00,0x00,0x00,0x00, // P 0x50
  0x00,0x00,0x3E,0x63,0x63,0x63,0x63,0x63,0x63,0x6B,0x6F,0x3E,0x06,0x07,0x00,0x00, // Q
  0x00,0x00,0x7E,0x33,0x33,0x33,0x3E,0x36,0x36,0x33,0x33,0x73,0x00,0x00,0x00,0x00, // R
  0x00,0x00,0x3E,0x63,0x63,0x30,0x1C,0x06,0x03,0x63,0x63,0x3E,0x00,0x00,0x00,0x00, // S
  0x00,0x00,0xFF,0xDB,0x99,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00, // T
  0x00,0x00,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x3E,0x00,0x00,0x00,0x00, // U
  0x00,0x00,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x36,0x1C,0x08,0x00,0x00,0x00,0x00, // V
  0x00,0x00,0x63,0x63,0x63,0x63,0x63,0x6B,0x6B,0x7F,0x36,0x36,0x00,0x00,0x00,0x00, // W
  0x00,0x00,0xC3,0xC3,0x66,0x3C,0x18,0x18,0x3C,0x66,0xC3,0xC3,0x00,0x00,0x00,0x00, // X
  0x00,0x00,0xC3,0xC3,0xC3,0x66,0x3C,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00, // Y
  0x00,0x00,0x7F,0x63,0x43,0x06,0x0C,0x18,0x30,0x61,0x63,0x7F,0x00,0x00,0x00,0x00, // Z
  0x00,0x00,0x3C,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x3C,0x00,0x00,0x00,0x00, // [
  0x00,0x00,0x80,0xC0,0xE0,0x70,0x38,0x1C,0x0E,0x07,0x03,0x01,0x00,0x00,0x00,0x00, // \ (back slash)
  0x00,0x00,0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00,0x00,0x00,0x00, // ]
  0x08,0x1C,0x36,0x63,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // ^
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00, // _
  0x18,0x18,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // ` 0x60
  0x00,0x00,0x00,0x00,0x00,0x3C,0x46,0x06,0x3E,0x66,0x66,0x3B,0x00,0x00,0x00,0x00, // a
  0x00,0x00,0x70,0x30,0x30,0x3C,0x36,0x33,0x33,0x33,0x33,0x6E,0x00,0x00,0x00,0x00, // b
  0x00,0x00,0x00,0x00,0x00,0x3E,0x63,0x60,0x60,0x60,0x63,0x3E,0x00,0x00,0x00,0x00, // c
  0x00,0x00,0x0E,0x06,0x06,0x1E,0x36,0x66,0x66,0x66,0x66,0x3B,0x00,0x00,0x00,0x00, // d
  0x00,0x00,0x00,0x00,0x00,0x3E,0x63,0x63,0x7E,0x60,0x63,0x3E,0x00,0x00,0x00,0x00, // e
  0x00,0x00,0x1C,0x36,0x32,0x30,0x7C,0x30,0x30,0x30,0x30,0x78,0x00,0x00,0x00,0x00, // f
  0x00,0x00,0x00,0x00,0x00,0x3B,0x66,0x66,0x66,0x66,0x3E,0x06,0x66,0x3C,0x00,0x00, // g
  0x00,0x00,0x70,0x30,0x30,0x36,0x3B,0x33,0x33,0x33,0x33,0x73,0x00,0x00,0x00,0x00, // h
  0x00,0x00,0x0C,0x0C,0x00,0x1C,0x0C,0x0C,0x0C,0x0C,0x0C,0x1E,0x00,0x00,0x00,0x00, // i
  0x00,0x00,0x06,0x06,0x00,0x0E,0x06,0x06,0x06,0x06,0x06,0x66,0x66,0x3C,0x00,0x00, // j
  0x00,0x00,0x70,0x30,0x30,0x33,0x33,0x36,0x3C,0x36,0x33,0x73,0x00,0x00,0x00,0x00, // k
  0x00,0x00,0x1C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x1E,0x00,0x00,0x00,0x00, // l
  0x00,0x00,0x00,0x00,0x00,0x6E,0x7F,0x6B,0x6B,0x6B,0x6B,0x6B,0x00,0x00,0x00,0x00, // m
  0x00,0x00,0x00,0x00,0x00,0x6E,0x33,0x33,0x33,0x33,0x33,0x33,0x00,0x00,0x00,0x00, // n
  0x00,0x00,0x00,0x00,0x00,0x3E,0x63,0x63,0x63,0x63,0x63,0x3E,0x00,0x00,0x00,0x00, // o
  0x00,0x00,0x00,0x00,0x00,0x6E,0x33,0x33,0x33,0x33,0x3E,0x30,0x30,0x78,0x00,0x00, // p 0x70
  0x00,0x00,0x00,0x00,0x00,0x3B,0x66,0x66,0x66,0x66,0x3E,0x06,0x06,0x0F,0x00,0x00, // q
  0x00,0x00,0x00,0x00,0x00,0x6E,0x3B,0x33,0x30,0x30,0x30,0x78,0x00,0x00,0x00,0x00, // r
  0x00,0x00,0x00,0x00,0x00,0x3E,0x63,0x38,0x0E,0x03,0x63,0x3E,0x00,0x00,0x00,0x00, // s
  0x00,0x00,0x08,0x18,0x18,0x7E,0x18,0x18,0x18,0x18,0x1B,0x0E,0x00,0x00,0x00,0x00, // t
  0x00,0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x66,0x3B,0x00,0x00,0x00,0x00, // u
  0x00,0x00,0x00,0x00,0x00,0x63,0x63,0x36,0x36,0x1C,0x1C,0x08,0x00,0x00,0x00,0x00, // v
  0x00,0x00,0x00,0x00,0x00,0x63,0x63,0x63,0x6B,0x6B,0x7F,0x36,0x00,0x00,0x00,0x00, // w
  0x00,0x00,0x00,0x00,0x00,0x63,0x36,0x1C,0x1C,0x1C,0x36,0x63,0x00,0x00,0x00,0x00, // x
  0x00,0x00,0x00,0x00,0x00,0x63,0x63,0x63,0x63,0x63,0x3F,0x03,0x06,0x3C,0x00,0x00, // y
  0x00,0x00,0x00,0x00,0x00,0x7F,0x66,0x0C,0x18,0x30,0x63,0x7F,0x00,0x00,0x00,0x00, // z
  0x00,0x00,0x0E,0x18,0x18,0x18,0x70,0x18,0x18,0x18,0x18,0x0E,0x00,0x00,0x00,0x00, // {
  0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00, // |
  0x00,0x00,0x70,0x18,0x18,0x18,0x0E,0x18,0x18,0x18,0x18,0x70,0x00,0x00,0x00,0x00, // }
  0x00,0x00,0x3B,0x6E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // ~
  0x00,0x70,0xD8,0xD8,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}; // DEL


const char* ssid     = "zodiac-ap";
const char* password = "20100613";
const char* host = "www.cwb.gov.tw";
const char* today = "今日:";
const char* rain = "降雨率:";
const char* temperature = "溫度:";

unsigned char localdebug = 0;
File localfile;
unsigned char charbuf;
WiFiClient client;

class CHTDisplay {
  private:
      void _lcdwrite(byte,byte);
      void _bufrotate(const unsigned char *, unsigned char *);
      void _bufrotate8x16(const unsigned char *, unsigned char *);
      unsigned int _utf8_to_ucode(unsigned long);
      void _presentbmp16x16(unsigned char,unsigned char,const unsigned char *);
      void _presentbmp8x16(unsigned char,unsigned char,const unsigned char *);
      File font;
  public:
      CHTDisplay(const char *);
      void PresentUTF8(unsigned char, unsigned char,const unsigned long);
      void PresentAscii(unsigned char, unsigned char,const unsigned char);
      void PresentUTF8Line(unsigned char, unsigned char, const char *, unsigned int);
      ~CHTDisplay();
};


class CharParse {
  private:
    char _start_string[20],_end_string[20];
    unsigned int _start_string_len, _end_string_len;
    char byte_array[60];
    unsigned int _collected_count;
    char *pChar_To_Compare;
    unsigned int _cur_instance, _target_nth_instance;
    unsigned int _cur_skip_count, _target_skip_count;
    enum ParseState {ParseForStart, InSkip, CollectParseForEnd};
    ParseState CurParseState;
    void (*_callback)(char [], unsigned int);
  public:
     void SetParseString(const char *, unsigned int, unsigned int, const char *, void (*)(char [], unsigned int)); //Set string to look for, nth instance and skip first n bytes and collect bytes until end string is reached. And then callback will be called.
     void ResetParseState(void);
     void ParseCharStream(char);    
};

CharParse myparse;

CHTDisplay::CHTDisplay(const char *filename) {
  if(!filename)
    Serial.println("Wrong filename");
  font = SPIFFS.open(filename, "r");
  if (!font) {
    Serial.println("Failed to open font file");
  } else {
    Serial.println("Open font ok");
  }  
}

CHTDisplay::~CHTDisplay(void){
  if(!!font)
    font.close();
}

void CHTDisplay::PresentUTF8(unsigned char hz,unsigned char vt, const unsigned long utf8) {
  unsigned int ucode = _utf8_to_ucode(utf8);
  unsigned char cht_buf[32],present_buf[32];
  if(ucode < 0x4e00 || ucode > 0x9fa5){
    Serial.println("Wrong unicode range");
    return;
  }
  if(!font.seek((ucode-0x4e00)*32,SeekSet)) {
    Serial.println("Error seeking to destination");
    return;
  }
  font.readBytes(cht_buf,32);
  for(int i=0;i<32;i++)
    Serial.printf("\t0x%x",cht_buf[i]);
  _bufrotate(cht_buf,present_buf);
  _presentbmp16x16(hz,vt,present_buf);
}

void CHTDisplay::_lcdwrite(byte dc, byte data)
{
  digitalWrite(PIN_DC, dc);
  digitalWrite(PIN_SCE, LOW);
  shiftOut(PIN_SDIN, PIN_SCLK, MSBFIRST, data);
  digitalWrite(PIN_SCE, HIGH);
}

void CHTDisplay::_bufrotate(const unsigned char src_buf[],unsigned char des_buf[])
{
  unsigned char x,y,z,bitmask,tempbit,tempbyte;
  for(z=0;z<=1;z++) {
    for(x=0;x<16;x++){
      tempbyte=0;
      bitmask=0x80 >> (x%8);
      for(y=0;y<8;y++){
        tempbit= ((src_buf[2*y+x/8+z*16]) & bitmask) << (x%8);
        tempbit = tempbit >> (7-y);
        tempbyte |= tempbit;
      }
      des_buf[x+z*16]=tempbyte;
    }
  }
}

void CHTDisplay::_bufrotate8x16(const unsigned char src_buf[], unsigned char des_buf[])
{
  unsigned char x,y,z,bitmask,tempbit,tempbyte;
  for(z=0;z<=1;z++) {
   for(x=0;x<8;x++) {
     tempbyte=0;
     bitmask=0x01 << x;
     for(y=0;y<8;y++) {
       tempbit=(src_buf[y+z*8]&bitmask) >> x;
       tempbit = tempbit << y;
       tempbyte |= tempbit;
     }
     des_buf[(7-x)+z*8]=tempbyte;
  }
 }
}


void CHTDisplay::_presentbmp16x16(unsigned char h, unsigned char v,const unsigned char toshow[])
{
  unsigned char i;
  _lcdwrite(0,((h&0xf0)>>4)|0x10); //set high nibble of column
  _lcdwrite(0,h&0x0f); //set low nibble
  _lcdwrite(0,(v&0x0f)|0xb0);
  for(i=0;i<16;i++)
    _lcdwrite(1,toshow[i]);
  _lcdwrite(0,((h&0xf0)>>4)|0x10); //set high nibble of column
  _lcdwrite(0,h&0x0f); //set low nibble
  _lcdwrite(0,((v+1)&0x0f)|0xb0);
  for(i=16;i<32;i++)
    _lcdwrite(1,toshow[i]);
}

void CHTDisplay::_presentbmp8x16(unsigned char h, unsigned char v,const unsigned char toshow[])
{
  unsigned char i;
  _lcdwrite(0,((h&0xf0)>>4)|0x10); //set high nibble of column
  _lcdwrite(0,h&0x0f); //set low nibble
  _lcdwrite(0,(v&0x0f)|0xb0);
  for(i=0;i<8;i++)
    _lcdwrite(1,toshow[i]);
  _lcdwrite(0,((h&0xf0)>>4)|0x10); //set high nibble of column
  _lcdwrite(0,h&0x0f); //set low nibble
  _lcdwrite(0,((v+1)&0x0f)|0xb0);
  for(i=8;i<16;i++)
    _lcdwrite(1,toshow[i]);
}



unsigned int CHTDisplay::_utf8_to_ucode(unsigned long utf8_src)
{
  unsigned long ucode_temp = 0;
  ucode_temp  = (utf8_src&0x000f0000)  >> 4;
  ucode_temp |= ((utf8_src&0x00003f00) >> 2);
  ucode_temp |=  utf8_src&0x0000003f;
  return (unsigned int) ucode_temp;
}

void CHTDisplay::PresentAscii(unsigned char hz, unsigned char vt, unsigned char asciicode)
{
  unsigned char asciibmp_r[16];
  Serial.println("Showing ascii");
  _bufrotate8x16(asciibmp+(asciicode-0x1f)*16,asciibmp_r);
   _presentbmp8x16(hz, vt, asciibmp_r);
}

void CHTDisplay::PresentUTF8Line(unsigned char hz, unsigned char vt, const char *utf8array, unsigned int arraylen)
{
  unsigned char charindex = 0;
  unsigned long utf8word = 0;
  while(charindex < arraylen) {
    if(utf8array[charindex] & 0x80) {
      utf8word = (utf8array[charindex] << 16) | (utf8array[charindex+1] << 8) | utf8array[charindex+2] ;
      charindex+=3;
      Serial.printf("Presenting utf8 0x%x, charindex = %d, hz = %d, vt = %d\n", utf8word, charindex, hz, vt);
      PresentUTF8(hz, vt, utf8word);
      hz+=16;
    } else {
      Serial.println("ASCII found");
      //ASCII present to be implemented here
      if(utf8array[charindex]!=' ') {//skip space
         PresentAscii(hz, vt, utf8array[charindex]);
         hz+=8;
      }
      charindex++;
    }
  }
}

void CharParse::SetParseString(const char *StartStr, unsigned int NthInstance, unsigned int SkipCount, const char *EndStr, void (*callback)(char [], unsigned int)) {
  int index = 0;
  //Initialize local variables
  CurParseState = ParseForStart;
  _collected_count = 0;
  _cur_instance = 0;
  _cur_skip_count = 0;
  //Copy arguments to local
  do {                                //copy Start String to local
    _start_string[index] = *StartStr;
    index++;
    StartStr++;
  } while(*StartStr!='\0' && index < 20);
  _start_string_len = index;
  _start_string[index] = '\0'; //ending copied string with null
  
  index = 0;
  do {  //copy End String to local
    _end_string[index] = *EndStr;
    Serial.printf("end string[%d]=0x%x\n",index,_end_string[index]);
    index++;
    EndStr++;
  } while(*EndStr!='\0' && index < 20);
  _end_string_len = index;
  _end_string[index] = '\0'; //ending copying string with null
  _target_nth_instance = NthInstance;
  _target_skip_count = SkipCount;
  _callback = callback;
  pChar_To_Compare = _start_string; //Point to the first element of copied start string
}

void CharParse::ResetParseState(void) {
  //Initialize local variables
  CurParseState = ParseForStart;
  _collected_count = 0;
  _cur_instance = 0;
  _cur_skip_count = 0;
  pChar_To_Compare = _start_string; 
}

void CharParse::ParseCharStream(char inputc) {
  switch(CurParseState) {
    case ParseForStart:
       if(*(pChar_To_Compare+1) == '\0' && inputc == *pChar_To_Compare) { //Next one being NULL means this is the last character to match
        Serial.println("Start String fully matched!");
        _cur_instance++;
          if(_cur_instance == _target_nth_instance) {
           Serial.println("Target instance reached");
           CurParseState = InSkip;
           pChar_To_Compare = _end_string; //Next searching will be end string
          } else {
           Serial.println("Current instance ++, looking for next one");
           pChar_To_Compare = _start_string;
          }        
       } else if (inputc == *pChar_To_Compare) {
        Serial.printf("<P1>");
        pChar_To_Compare++;
       } else {
        Serial.printf("<M1>");
        pChar_To_Compare = _start_string;
       }
       break;
     case InSkip:
       if(_cur_skip_count == _target_skip_count) {
        Serial.println("Skip count reached, collect 1st byte");
        byte_array[0] = inputc;
        _collected_count++;
        CurParseState = CollectParseForEnd;
       } else {
        Serial.println("Skip count ++");
        _cur_skip_count++;
       }
       break;
     case CollectParseForEnd:
       if(*pChar_To_Compare == '\0') {
         Serial.println("End String fully matched, execute callback");
         _callback(byte_array, _collected_count - _end_string_len); //subtract end string length from collect count
         Serial.println("Finish callback");
       } else if(inputc == *pChar_To_Compare) {
         Serial.printf("<P2>");
         byte_array[_collected_count] = inputc; //Suspicious tag but still store into buffer
         pChar_To_Compare++;
         _collected_count++;
       } else {
         Serial.printf("<0x%x!=0x%x>", inputc, *pChar_To_Compare);
         byte_array[_collected_count] = inputc;
         _collected_count++;
         pChar_To_Compare = _end_string; //mismatch, restart from begining
       }
      break;
  }
}

void LcdClear(void)
{
   LcdWrite(0,0x10);
   LcdWrite(0,0x00);
   LcdWrite(0,0xb0);
  for (int index = 0; index < LCD_X * LCD_Y / 8; index++)
  {
    LcdWrite(LCD_D, 0x00);
  }
}

void LcdInitialise(void)
{
  pinMode(PIN_SCE, OUTPUT);
  pinMode(PIN_RESET, OUTPUT);
  pinMode(PIN_DC, OUTPUT);
  pinMode(PIN_SDIN, OUTPUT);
  pinMode(PIN_SCLK, OUTPUT);
  digitalWrite(PIN_RESET, LOW);
  delay(20);
  digitalWrite(PIN_RESET, HIGH);
  LcdWrite(LCD_C, 0xe2 ); //soft reset
  delay(5);
  LcdWrite(LCD_C, 0x2c );
  delay(5);
  LcdWrite(LCD_C, 0x2e );
  delay(5);
  LcdWrite(LCD_C, 0x2f );
  delay(5);
  LcdWrite(LCD_C,0x24);
  LcdWrite(LCD_C,0x81); 
  LcdWrite(LCD_C,0x0f);
  LcdWrite(LCD_C,0xa2); 
  LcdWrite(LCD_C,0xc8); 
  LcdWrite(LCD_C,0xa0); 
  LcdWrite(LCD_C,0x40); 
  LcdWrite(LCD_C,0xaf); 

}

void LcdWrite(byte dc, byte data)
{
  digitalWrite(PIN_DC, dc);
  digitalWrite(PIN_SCE, LOW);
  shiftOut(PIN_SDIN, PIN_SCLK, MSBFIRST, data);
  digitalWrite(PIN_SCE, HIGH);
}

void dumpbuffer3(char revbuf[], unsigned int buflen) 
{
  int i;
  CHTDisplay mycht("/4e00_9fa5.dat");
  for(i = 0;i< buflen;i++) {
   Serial.printf("Parsed buf[%d] = 0x%x = <%c>\n",i, revbuf[i],revbuf[i]);
  }
  mycht.PresentUTF8Line(56,4, revbuf,buflen);
  Serial.println("Deep sleep 10sec...");
  ESP.deepSleep(30*60*1000000); //deep sleep 1hr
}

void dumpbuffer2(char revbuf[], unsigned int buflen) 
{
  int i;
  CHTDisplay mycht("/4e00_9fa5.dat");
  for(i = 0;i< buflen;i++) {
   Serial.printf("Parsed buf[%d] = 0x%x = <%c>\n",i, revbuf[i],revbuf[i]);
  }
  mycht.PresentUTF8Line(40,2, revbuf,buflen);
  myparse.SetParseString("雨機率:", 1, 1 ," ", dumpbuffer3);
  Serial.println("Setting #3 search");
}

void dumpbuffer1(char revbuf[], unsigned int buflen) 
{
  int i;
  CHTDisplay mycht("/4e00_9fa5.dat");
  for(i = 0;i< buflen;i++) {
   Serial.printf("Parsed buf[%d] = 0x%x = <%c>\n",i, revbuf[i],revbuf[i]);
  }
  mycht.PresentUTF8Line(40,0, revbuf,buflen);
  myparse.SetParseString("溫度:", 1, 1 ," 降", dumpbuffer2);
  Serial.println("Setting #2 search");
}

void showui(void)
{
   CHTDisplay myui("/4e00_9fa5.dat");
   myui.PresentUTF8Line(0,0, today,7); 
   myui.PresentUTF8Line(0,2, temperature,7);
   myui.PresentUTF8Line(0,4, rain,10);  
}

void setup(void)
{
  unsigned long utf8test=0xe69dbf;
  Serial.begin(115200);
 // ESP.wdtDisable();
  LcdInitialise();
  LcdClear();
  if (!SPIFFS.begin()) {
    Serial.println("Failed to mount file system");
    return;
  }
  showui();
  if(localdebug == 1) {
    localfile = SPIFFS.open("/36_01.xml", "r");
    if(!localfile)
       Serial.println("Error open local test file");
    myparse.SetParseString("CDATA[ 臺北市", 1, 0 ," ", dumpbuffer1);       
  } else {
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }

  Serial.println("");
  Serial.println("WiFi connected");  
  Serial.println("IP address: ");
  delay(0);
  myparse.SetParseString("CDATA[ 臺北市", 1, 0 ," ", dumpbuffer1);
  Serial.println(WiFi.localIP());
  delay(1000);
  while (!client.connect(host, 80)) {
    Serial.println("connection failed");
    delay(2000);
  }
  client.println("GET /rss/forecast/36_01.xml HTTP/1.1");
  client.println("Host: www.cwb.gov.tw");
  client.println("Connection: close");
  client.println();
  }
}

void loop(void)
{
   if(localdebug == 1) {
    while(localfile.readBytes(&charbuf,1)) {
      Serial.write(charbuf);
      myparse.ParseCharStream(charbuf);
    }
    while(true)
      yield();
   } else {
   while (client.available()) {
    char c = client.read();
    Serial.write(c);
    myparse.ParseCharStream(c);
  }

  // if the server's disconnected, stop the client:
  if (!client.connected()) {
    Serial.println();
    Serial.println("disconnecting from server.");
    client.stop();

    // do nothing forevermore:
    while(true);
  }
   }
}

